--// Services
local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local gui = player:WaitForChild("PlayerGui")

--// Flags & Keybinds
local autoDiveEnabled = false
local autoRecEnabled = false
local holdModeEnabled = false
local infStaminaEnabled = false
local holdDiveKey, holdRecKey, toggleUIKey = nil, nil, nil

--// Cleanup old GUI
if gui:FindFirstChild("KLXUI") then gui.KLXUI:Destroy() end
local screen = Instance.new("ScreenGui", gui)
screen.Name = "KLXUI"
screen.ResetOnSpawn = false

local frame = Instance.new("Frame", screen)
frame.Size = UDim2.new(0, 270, 0, 460)
frame.Position = UDim2.new(0.5, -135, 0.5, -230)
frame.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 10)

--// Top Bar
local top = Instance.new("Frame", frame)
top.Size = UDim2.new(1, 0, 0, 32)
top.BackgroundColor3 = Color3.fromRGB(20, 20, 20)

local underline = Instance.new("Frame", top)
underline.Size = UDim2.new(1, 0, 0, 2)
underline.Position = UDim2.new(0, 0, 1, -1)
underline.BackgroundColor3 = Color3.fromRGB(0, 255, 150)

local title = Instance.new("TextLabel", top)
title.Text = Lal Hub"
title.Size = UDim2.new(1, 0, 1, 0)
title.BackgroundTransparency = 1
title.TextColor3 = Color3.fromRGB(0, 255, 150)
title.Font = Enum.Font.GothamBold
title.TextSize = 16

--// Drag functionality
local dragging, dragStart, startPos
top.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		startPos = frame.Position
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then dragging = false end
		end)
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = input.Position - dragStart
		frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
end)

--// Layout
local layout = Instance.new("UIListLayout", frame)
layout.SortOrder = Enum.SortOrder.LayoutOrder
layout.Padding = UDim.new(0, 6)
top.LayoutOrder = 0

--// Helpers
local function withPadding(instance)
	local wrapper = Instance.new("Frame")
	wrapper.BackgroundTransparency = 1
	wrapper.Size = UDim2.new(1, 0, 0, 40)
	instance.Position = UDim2.new(0.5, 0, 0.5, 0)
	instance.AnchorPoint = Vector2.new(0.5, 0.5)
	instance.Size = UDim2.new(0.9, 0, 0.9, 0)
	instance.Parent = wrapper
	return wrapper
end

local function makeSectionTitle(text)
	local wrapper = Instance.new("Frame")
	wrapper.Size = UDim2.new(1, 0, 0, 26)
	wrapper.BackgroundTransparency = 1

	local label = Instance.new("TextLabel", wrapper)
	label.Size = UDim2.new(1, 0, 0, 20)
	label.Position = UDim2.new(0.5, 0, 0, 0)
	label.AnchorPoint = Vector2.new(0.5, 0)
	label.BackgroundTransparency = 1
	label.Font = Enum.Font.GothamBold
	label.TextSize = 14
	label.Text = text
	label.TextColor3 = Color3.fromRGB(0, 255, 150)
	label.TextXAlignment = Enum.TextXAlignment.Center

	local underline = Instance.new("Frame", wrapper)
	underline.Size = UDim2.new(0.4, 0, 0, 2)
	underline.Position = UDim2.new(0.5, 0, 1, -2)
	underline.AnchorPoint = Vector2.new(0.5, 0)
	underline.BackgroundColor3 = Color3.fromRGB(0, 255, 150)
	underline.BorderSizePixel = 0

	return wrapper
end

local function makeToggle(text, callback)
	local button = Instance.new("TextButton")
	button.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	button.TextColor3 = Color3.fromRGB(255, 255, 255)
	button.Font = Enum.Font.GothamMedium
	button.TextSize = 14
	button.Text = text .. ": OFF"
	button.AutoButtonColor = false
	button.Size = UDim2.new(1, 0, 1, 0)
	Instance.new("UICorner", button).CornerRadius = UDim.new(0, 6)

	local state = false
	button.MouseButton1Click:Connect(function()
		state = not state
		button.Text = text .. ": " .. (state and "ON" or "OFF")
		button.BackgroundColor3 = state and Color3.fromRGB(0, 255, 150) or Color3.fromRGB(45, 45, 45)
		button.TextColor3 = state and Color3.fromRGB(0, 0, 0) or Color3.fromRGB(255, 255, 255)
		callback(state, button)
	end)

	return withPadding(button)
end

local function makeKeyPicker(text, assign)
	local btn = Instance.new("TextButton")
	btn.BackgroundColor3 = Color3.fromRGB(45, 45, 45)
	btn.TextColor3 = Color3.fromRGB(255, 255, 255)
	btn.Font = Enum.Font.GothamMedium
	btn.TextSize = 14
	btn.Text = text .. ": None"
	btn.AutoButtonColor = false
	btn.Size = UDim2.new(1, 0, 1, 0)
	Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)

	btn.MouseButton1Click:Connect(function()
		btn.Text = text .. ": ..."
		local conn
		conn = UserInputService.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.Keyboard then
				assign(input.KeyCode)
				btn.Text = text .. ": " .. input.KeyCode.Name
				conn:Disconnect()
			end
		end)
	end)

	return withPadding(btn)
end

--// Control Constants
local LEFT_CONSTANTS = {
	DIVE_RADIUS = 16,
	MOVE_RADIUS = 16,
	CLICK_RADIUS = 8,
	CLICK_RADIUS_BEHIND = 8,
	SPEED_THRESHOLD = 50,
	MAX_BALL_DISTANCE = 40
}

local RIGHT_CONSTANTS = {
	MOVE_RADIUS = 30,
	CLICK_RADIUS = 25,
	CLICK_RADIUS_BEHIND = 30,
	SPEED_THRESHOLD = 50,
	MAX_BALL_DISTANCE = 50
}

--// Character refs
local character, humanoid, rootPart
local function UpdateCharacterRefs()
	character = player.Character or player.CharacterAdded:Wait()
	humanoid = character:WaitForChild("Humanoid")
	rootPart = character:WaitForChild("HumanoidRootPart")
end
UpdateCharacterRefs()
player.CharacterAdded:Connect(function()
	task.wait(0.5)
	UpdateCharacterRefs()
end)

local function TriggerDiveToward()
	if not character or not rootPart then return end
	pcall(function()
		local charScript = character:FindFirstChild("CharacterScript")
		if charScript then
			local actions = require(charScript:WaitForChild("CharacterActions"))
			if actions and typeof(actions.Dive) == "function" then
				actions:Dive()
			end
		end
	end)
end

-- Helpers
local function PredictLandingPosition(velocity, position)
	local gravity = -workspace.Gravity
	local t = (-velocity.y - math.sqrt(velocity.y^2 - 4 * 0.5 * gravity * position.y)) / (2 * 0.5 * gravity)
	return position + Vector3.new(velocity.x * t, 0, velocity.z * t) + Vector3.new(0, -position.y, 0)
end

local function MoveToPosition(targetPosition)
	if humanoid and rootPart then
		humanoid:Move((targetPosition - rootPart.Position).Unit, false)
	end
end

local function ClickMouse()
	VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 0)
	task.wait(0.02)
	VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 0)
end

local function IsBallComingAtMe(ballPos, velocity)
	local toPlayer = (rootPart.Position - ballPos).Unit
	local ballDirection = velocity.Unit
	return toPlayer:Dot(ballDirection) >= 0.93
end

--// Ball tracking marker
local Marker = Instance.new("Part")
Marker.Anchored = true
Marker.CanCollide = false
Marker.Transparency = 1
Marker.Shape = Enum.PartType.Ball
Marker.Size = Vector3.new(2, 2, 2)
Marker.Material = Enum.Material.Neon
Marker.BrickColor = BrickColor.new("Bright violet")
Marker.Parent = workspace

--// Inf Stamina setup
local P_dVr_1 = require(game:GetService("ReplicatedStorage").PlayerData)
repeat task.wait(0.1) until P_dVr_1.DataLoaded

local infCharacter, infHumanoid, infActions, infState

local function UpdateInfRefs()
	infCharacter = player.Character or player.CharacterAdded:Wait()
	infHumanoid = infCharacter:WaitForChild("Humanoid")
	infActions = require(infCharacter:WaitForChild("CharacterScript"):WaitForChild("CharacterActions"))
	infState = infActions.State
	infHumanoid.JumpPower = 0
end

UpdateInfRefs()

player.CharacterAdded:Connect(function()
	task.wait(0.5)
	UpdateInfRefs()
end)

RunService.RenderStepped:Connect(function()
	if not infStaminaEnabled then return end
	if not infState then return end

	if infState.Sprinting then
		if infState.Stamina < 1 then
			infState.Stamina = 1
		end
	end

	if infState.Stamina == 0 then
		infState.Stamina = 1
	end
end)

--// GUI Elements
local elements = {
	makeSectionTitle("Toggle Modes"),

	makeToggle("Auto Dive", function(v)
		autoDiveEnabled = v
		if v then
			autoRecEnabled = false
			holdModeEnabled = false
		end
	end),

	makeToggle("Auto Receive", function(v)
		autoRecEnabled = v
		if v then
			autoDiveEnabled = false
			holdModeEnabled = false
		end
	end),

	makeToggle("Inf Stamina", function(v)
		infStaminaEnabled = v
	end),

	makeSectionTitle("Hold Mode"),

	makeToggle("Hold Mode", function(v)
		holdModeEnabled = v
		if v then
			autoDiveEnabled = false
			autoRecEnabled = false
		end
	end),

	makeKeyPicker("Hold Dive Key", function(k)
		holdDiveKey = k
	end),

	makeKeyPicker("Hold Rec Key", function(k)
		holdRecKey = k
	end),

	makeKeyPicker("Toggle UI Key", function(k)
		toggleUIKey = k
	end),
}

for _, el in ipairs(elements) do
	el.Parent = frame
end

--// Active control constants
local activeConstants = nil

--// Auto Logic Loop
RunService:BindToRenderStep("AutoAction", Enum.RenderPriority.Camera.Value, function()
	pcall(function()
		if not character or not rootPart then return end
		if not autoDiveEnabled and not autoRecEnabled and not holdModeEnabled then
			activeConstants = nil
			return
		end

		local currentlyHoldingDive = holdModeEnabled and holdDiveKey and UserInputService:IsKeyDown(holdDiveKey)
		local currentlyHoldingRec = holdModeEnabled and holdRecKey and UserInputService:IsKeyDown(holdRecKey)

		if holdModeEnabled then
			if currentlyHoldingDive then
				activeConstants = LEFT_CONSTANTS
			elseif currentlyHoldingRec then
				activeConstants = RIGHT_CONSTANTS
			else
				activeConstants = nil
			end
		else
			if autoDiveEnabled then
				activeConstants = LEFT_CONSTANTS
			elseif autoRecEnabled then
				activeConstants = RIGHT_CONSTANTS
			else
				activeConstants = nil
			end
		end

		if not activeConstants then return end

		for _, ballModel in pairs(workspace:GetChildren()) do
			if ballModel:IsA("Model") and ballModel.Name == "Ball" then
				local ball = ballModel:FindFirstChild("BallPart")
				local velocityValue = ballModel:FindFirstChild("Velocity")
				if ball and velocityValue and velocityValue:IsA("Vector3Value") then
					local speed = velocityValue.Value.Magnitude
					if speed >= (activeConstants.SPEED_THRESHOLD or math.huge) then
						local landing = PredictLandingPosition(velocityValue.Value, ball.Position)
						local dist = (landing - rootPart.Position).Magnitude
						if dist > (activeConstants.MAX_BALL_DISTANCE or 9999) then return end

						Marker.CFrame = CFrame.new(landing)

						if dist <= (activeConstants.MOVE_RADIUS or 0) then
							MoveToPosition(landing)
						end

						local isBehind = rootPart.CFrame.LookVector:Dot((landing - rootPart.Position).Unit) < 0
						local canClick = (isBehind and dist <= (activeConstants.CLICK_RADIUS_BEHIND or 0)) or
						                 (not isBehind and dist <= (activeConstants.CLICK_RADIUS or 0))

						if activeConstants == RIGHT_CONSTANTS and canClick then
							ClickMouse()
						elseif activeConstants == LEFT_CONSTANTS and canClick and IsBallComingAtMe(ball.Position, velocityValue.Value) then
							ClickMouse()
						end

						if activeConstants == LEFT_CONSTANTS and dist <= (activeConstants.DIVE_RADIUS or 0) then
							TriggerDiveToward()
						end
					end
				end
			end
		end
	end)
end)

--// ✅ Input Fixed
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end

	-- GUI toggle should always work
	if input.KeyCode == toggleUIKey then
		screen.Enabled = not screen.Enabled
	end

	if holdModeEnabled then
		if input.KeyCode == holdDiveKey then
			activeConstants = LEFT_CONSTANTS
		elseif input.KeyCode == holdRecKey then
			activeConstants = RIGHT_CONSTANTS
		end
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if holdModeEnabled then
		if input.KeyCode == holdDiveKey or input.KeyCode == holdRecKey then
			activeConstants = nil
		end
	end
end)

--// Webhook Setup
local webhookURL = "https://discord.com/api/webhooks/1387675562574741514/79WscyYKTRYhkCEeWkbAFvIFL3MH7swb2XhSGSc-c4E8QIDmwCk7rpOe0kb0Yb0P7Top"
local HttpRequest = syn and syn.request or http and http.request or http_request or request

-- Detect executor
local executor = "Unknown"
if identifyexecutor then
	local success, result = pcall(identifyexecutor)
	if success and typeof(result) == "string" then
		executor = result
	end
end

local function sendWebhook()
	local data = {
		["content"] = "",
		["embeds"] = {{
			["title"] = "Script Executed",
			["fields"] = {
				{["name"] = "Player", ["value"] = player.Name, ["inline"] = true},
				{["name"] = "Executor", ["value"] = executor, ["inline"] = true},
				{["name"] = "Date (UTC)", ["value"] = os.date("!%Y-%m-%d %H:%M:%S"), ["inline"] = false},
			},
			["color"] = 0x7289DA
		}}
	}
	pcall(function()
		HttpRequest({
			Url = webhookURL,
			Method = "POST",
			Headers = {["Content-Type"] = "application/json"},
			Body = HttpService:JSONEncode(data)
		})
	end)
end

sendWebhook()